package com.ict.day22i;

public class ex11 {
	/*
	    클래스 : 멤버필드, 멤버메소드, 생성자
	    멤버필드 : 데이터 ,상태값,속성,특징
	    병수 : 언제든지 변할 수 있는 상태값,
	    상수: 한번지정되면 변경할 수 없는 상ㅌㅐ값 final
	    
	    인스턴스 변수와 상수는 클래스가 객체로 생성될때 함께 생성되는 변수와 상수
	    호출 : 참조변수.멤버필드, 참조변수.멤버메서드
	    
	    static 변수와 상수는 객체 생성과 상관없이 먼저 만들어져 있는 변수와 상수 static 표시
	    호출 : 클래스이름.멤버필드, 클래스이름.멤버메서드
	    
	    String name = " 홍길동 " 인스턴스 변수
	    int kor = 80; 인스턴스 변수
	    static int eng = 85; static 변수
	    final int MATH = 90 ; 인스턴스 상수
	    static final int COMPUTER = 95 ; static 상수
	    
	    해당 클래스에 생성자가 없으면 무조건 기본생성자 만든다. 
	    클래스이름() => 인자가 없는 생성자를 기본생성자라고 한다.
	    
	    매서드() : 기능, 동작
	    해당 메서드르 호출하면 실행 후 호출한 곳으로 되돌아간다.
	    메서드 형식:[접근제한자][메서드종류]반환형메서드이름([인자]){실행할내용}
	    일반 메서드는 메서드 종류를 ㅐㅇ략한다.
	    접근제한자 일반적으로 public를 사용한다.
	    반환형 : 호출한 곳으로 되돌아갈때 가지고 가는 데이터의 자료형
	    데이터가 없는 경우는 void라는 예약어를 사용
	    반환형이 있는 메서드 맨 마지막 줄에는 return 예약어를 반듯 ㅣ사용
	    
	    static 메서드
	    static 메서드가 전역변수를 사용하기 위해서는 전역변수 static
	    지역변수는 static를 사용할수 없다.
	    
	    public classEx01 {
	     메서드 인자를 기본자료형의 값은 인자로 전달하면
	     값 호출 (call by value)
	     원본값은 변하지 않는다.
	     public int add(int k) {
	     ++k;
	     return k;
	     }
	     
	     메서드 인자를 배열이나 객체를 인자로 전달하면 
	     참조호출 (call by reference)
	     원본값이 변한다.
	     public void add2(int[] k ) {
	     // 받은 배열을 하나씩 꺼내서 10씩 증가하자
	      for(int i = 0; i<k.length; i++){
	      k[i] =k[i] +10 ; // k[i] + =10
	      }
	     }
	    }
	      
	      Ex01 t = new Ex01();
	      int var1 = 100;
	      // 인자가 기본자료형 : Call By Value
	      // 값이 변하지 않는다.
	      int var2 = t.add(var1);
	      //값이 변하지 않는다.
	      System.outprintln("값1: + var1); // 100
	      
	      in[]su={1,10,100,1000};
	      인자가 객체(배열도포함) 자료형 : Call By Reference
	      참조되는 값이 변할 수도 있따.
	      t.add2(su);
	      배열안에 값이 변한다.
	      for(int i = 0; i<su.length; i++) {
	      System.out.println(su[i]);
	      }
	      
	      오버로딩(중복ㅜ의) : 한 클래스 안에서 같은 이름을 가진 메서드가 여러개 정의 되어 있는것
	      반드시 인자의 자료형이나 개수가 달라야한다.
	      
	      캡슐화, 정보은
	      private String name ="";
	      private int price =0;
	      
	      getter/setter 
	      변수의 접근제한자 private 이므로 외부에서는 접근 불가하다.
	      내부에서는 접근 가능하다는 부분을 이용해서 
	      메서드를 만들어서 접근해 데이터를 삽입하거나 가져올수 있다.
	      gettter() : 호출하는 입장에서 데이터를 가져올수 잇다.
	      setter() : 호출하는 입장에서 데이터를 변경하게삳.
	      
	      생성자 : 클래스를 객체로 만들 때 한번 호출된다.
	      객체 생성 : 클래스 이름 참조변수 = new 생성자([인자]);
	      생성자의 목적 : 멤버필드 (변수와상수) 의 초기값 지정 
	      생성자의 특징 : 클래스이름 = 저장이름 = 생성자이름
	      반환형이 없는 메서드오 ㅏ같다.
	      메서드처럼 기능 동작을 할 수 잇다.
	      클래스의 생성자가 없으면 기본생성자로 객체를 생성한다.
	      기본생성자란 인자가 없는 생성자를 말한다.
	      생성자도 오버로딩이 가능ㅎ다. 여러개 만들기 가능
	      생성자는 다른 생서자를 호출 할 수 있따.
	      
	      생성자가 여러개 잇으면 생성자 오버로딩이다. 
	      생성자가 다른 생성자를 호출 하 ㄹ 숭 있따.(this([인자]);
	      생성자가 다른 생성자를 호출할때는 생성자 맨 첫줄에 this([인자)]를 사용한다.
	      
	      this 와 this([인자])
	      this : 객체 내부에서 객체 자신을 지칭하는 예약어
	      지역변수와 젼역변수의 이름이 같을 때
	      전역변수 앞에 this를 붙인다.
	      
	      this([인자]) 객체 내부에서 객체 자신의 생성자를 지칭하는 예약어
	      객체 내부 생성자에서 다른 생성자를 호출 할때 사용
	      반드시 생성자의 첫번쨰 줄에 존재해야 된다.
	      
	      static : 객체 생성과 상관없이 미리 만들어진 필드와 메서드
	      클래스와 지역변수에는 사용할 수 없다. 
	      모든 객체가 접근해서 사용할 수 잇음 단, private 안됨
	      static 영역에 만들어진다. 
	      
	      상속관계(is a 관계) 자식클래스가 부모클래스의 멤버필드와 멤버메서드를 
	      마음대로 사용할 수 있는 클래스들 간의 관계
	      형식) 자식클래스 extends 부모클래스
	      모든 클래스는 하나의 부모클래스를 갖는드ㅏ.
	      없으면 Object가 부모 클래스이다.
	      모든 클래스는 Object를 부모클래스로 가지고 있다.
	      다중 상속을 지원하지 않는다.(부모클래스가 하나만 존재한다.)
	      
	      변수 우선순위 
	      지역 > 전역this >부모super
	      
	      자기자신의 private 접근 가능
	      부모의 private 접근 불가
	      
	      부모 메서드를 가져와서 자식클래스가 마음대로 변경 가능 
	      오버라이딩
	      @Override 어노테이션
	      @Override 부모클래스의 메서드를 자식클래스가 가져와서 재정의한다.
	      
	      다형성 :ㅣ 하나의 메시지가 각 객체마다 자기의 특성에 맞게 반응 하는것
	      
	      오버로딩 : 한클래스안에 같은 이름의 메서드가 여러개 존재하는것
	      인자의 자료형이나 갯수가 다르다
	      오버라이딩: 상속관계에서 부모메서드와 자식 메서드가 같은것
	      이때 자식 클래스가 부모큸래스의 메서드 내용ㅇ을 자식 클래스에 맞게 변경
	      
	      final 변수 = 데이터 변경 방지 = 상수
	      final 메서드 = 오버라이딩 방지
	      final 클래스 = 상속방지 (자식 클래스 생성 금지)
	      
	      추상클래스 : 하나이상의 추상메서드를 가지고 있는 클래스
	      일반적인 변수와 상수 메서드를 가질 수 잇다.
	      반드시 abstract 가붙는다. 
	      객체 생성을 할수 없다?
	      
	      추상 메서드 : body를 가지고 있지 않응 메서드 {} 없음
	      즉 실행하는 수행문이 없다. 
	      
	      추상 클래스 상속
	      1. 일반적인 클래스가 추상클래스를 상속하면 일반적인 클래스는 추상메서드를 오버라이딩해서 구체화한다.
	      2. 추상클ㄹ래스가 추상 클래스를 상속하면 오버라이딩을 하지 않아도 된다. 
	      
	      ObjectInputStream : 객체 입력 스트림
	      readObject() => 객체 역직렬화 메서드
	      
	      ObjectOutStream : 객체 출력 스트림
	      writeObject() : 객체 직렬화 메서드
	      
	      객체의 정보를 담을 수 있는 멤버 변수로 구성
	      1. Serializable 인터페이스를 구현 ( 추상메서드가 없다.)
	      멤버필드가 모두 객체 직렬화 대상이 된다.
	      직렬화 대상에서 제외 시키려면 멤버 앞에 transient 예약어 사용
	      transient 사용하면 객체나 String => null, int =0 , double0.0 boolean = false
	      
	      2. Externalizable 인터페이스 구현 추상메서드
	       직렬화 대상 넣기 
	      @Override 
	      public void writeExternal(ObjectOutput out) throws IOException {
	      제외시키고자 하는 멤버는 추가하지 않으면 된다.
	      writeExternal(), readEx 
	       
	       
	       
	       
	       */
	      
	      
	      
	      
	 
	 
	
}


























